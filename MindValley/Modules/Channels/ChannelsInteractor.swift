// 
//  ChannelsInteractor.swift
//  MindValley
//
//  Created by Canh Tran Wizeline on 4/9/20.
//  Copyright ¬© 2020 CanhTran. All rights reserved.
//
//  This file was generated by the üêç VIPER generator
//

import Foundation

final class ChannelsInteractor {
    private typealias MediasResponse = [String: [String: [Media]]]
    private typealias ChannelsResponse = [String: [String: [Channel]]]
    
    private let mediaLimit = 6
    
    // MARK: - Private Properties
    private let networkClient: NetworkRequestable

    // MARK: - LifeCycle

    init(networkClient: NetworkRequestable = NetworkClient()) {
        self.networkClient = networkClient
    }
}

// MARK: - ChannelsInteractorInterface

extension ChannelsInteractor: ChannelsInteractorInterface {
    func fetchNewEpisodes(loadFromCache: Bool, completion: @escaping (Result<[Media], NetworkError>) -> Void) {
        self.networkClient.fetch(endPoint: ChannelsAPI.fetchNewEpisodes,
                                 type: MediasResponse.self,
                                 loadFromCache: loadFromCache) { (result) in
                                    DispatchQueue.main.async {
                                        switch result {
                                        case .success(let resultData):
                                            if let data = resultData[NestedKey.data],
                                                var medias = data[NestedKey.media] {
                                                // Filter the maximum list of medias is 6
                                                if medias.count > self.mediaLimit {
                                                    medias = Array(medias[0..<self.mediaLimit])
                                                }
                                                completion(.success(medias))
                                            } else {
                                                completion(.success([]))
                                            }
                                        case .failure(let error):
                                            completion(.failure(error))
                                        }
                                    }
        }
    }
    
    func fetchChannels(loadFromCache: Bool, completion: @escaping (Result<[Channel], NetworkError>) -> Void) {
        self.networkClient.fetch(endPoint: ChannelsAPI.fetchChannels,
                                 type: ChannelsResponse.self,
                                 loadFromCache: loadFromCache) { (result) in
                                    DispatchQueue.main.async {
                                        switch result {
                                        case .success(let resultData):
                                            if let data = resultData[NestedKey.data],
                                                var channels = data[NestedKey.channels] {
                                                // Filter list media not more than 6 items.
                                                DispatchQueue.runBackgroundTask({
                                                    self.filterChannelsData(channels: &channels)
                                                }, completion: {
                                                    completion(.success(channels))
                                                })
                                            } else {
                                                completion(.success([]))
                                            }
                                        case .failure(let error):
                                            completion(.failure(error))
                                        }
                                    }
        }
    }
    
    /// Filter the result, every channel contains 6 series/media maximum
    /// - Parameter channels: channels response
    private func filterChannelsData(channels: inout [Channel]) {
        for i in 0..<channels.count {
            switch channels[i].type {
            case .course:
                if channels[i].latestMedia.count > mediaLimit {
                    channels[i].latestMedia = Array(channels[i].latestMedia[0..<mediaLimit])
                }
            case .series:
                if channels[i].series.count > mediaLimit {
                    channels[i].series = Array(channels[i].series[0..<mediaLimit])
                }
            }
        }
    }
}
